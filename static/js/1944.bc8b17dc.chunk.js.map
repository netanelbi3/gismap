{"version":3,"file":"static/js/1944.bc8b17dc.chunk.js","mappings":"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","sources":["../node_modules/@esri/calcite-components/dist/components/Heading.js","../node_modules/@esri/calcite-components/dist/components/array.js","../node_modules/@esri/calcite-components/dist/components/action-menu.js","../node_modules/@esri/calcite-components/dist/components/debounce.js","../node_modules/@esri/calcite-components/dist/components/openCloseComponent.js","../node_modules/@esri/calcite-components/dist/components/floating-ui.js","../node_modules/@esri/calcite-components/dist/components/focusTrapComponent.js","../node_modules/@esri/calcite-components/dist/components/FloatingArrow.js","../node_modules/@esri/calcite-components/dist/components/popover.js"],"sourcesContent":["/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { h } from '@stencil/core/internal/client/index.js';\n\nfunction constrainHeadingLevel(level) {\n  return Math.min(Math.max(Math.ceil(level), 1), 6);\n}\nconst Heading = (props, children) => {\n  const HeadingTag = props.level ? `h${props.level}` : \"div\";\n  delete props.level;\n  return h(HeadingTag, { ...props }, children);\n};\n\nexport { Heading as H, constrainHeadingLevel as c };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nfunction getRoundRobinIndex(index, total) {\n  return (index + total) % total;\n}\n\nexport { getRoundRobinIndex as g };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { proxyCustomElement, HTMLElement, createEvent, h, Fragment } from '@stencil/core/internal/client/index.js';\nimport { g as getRoundRobinIndex } from './array.js';\nimport { t as toAriaBoolean, j as isPrimaryPointerButton, k as focusElement } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { i as isActivationKey } from './key.js';\nimport { a as setUpLoadableComponent, s as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { d as defineCustomElement$4 } from './action.js';\nimport { d as defineCustomElement$3 } from './icon.js';\nimport { d as defineCustomElement$2 } from './loader.js';\nimport { d as defineCustomElement$1 } from './popover.js';\n\nconst CSS = {\n  menu: \"menu\",\n  defaultTrigger: \"default-trigger\",\n};\nconst SLOTS = {\n  tooltip: \"tooltip\",\n  trigger: \"trigger\",\n};\nconst ICONS = {\n  menu: \"ellipsis\",\n};\nconst activeAttr = \"data-active\";\n\nconst actionMenuCss = \":host{box-sizing:border-box;display:flex;flex-direction:column;font-size:var(--calcite-font-size-1);color:var(--calcite-ui-text-2)}.menu ::slotted(calcite-action){margin:0.125rem;display:flex;outline-color:transparent}.menu ::slotted(calcite-action[data-active]){outline:2px solid var(--calcite-ui-focus-color, var(--calcite-ui-brand));outline-offset:calc(\\n            2px *\\n            calc(\\n              1 -\\n              2 * clamp(\\n                0,\\n                var(--calcite-ui-focus-offset-invert),\\n                1\\n              )\\n            )\\n          );outline-offset:0px}.default-trigger{position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}slot[name=trigger]::slotted(calcite-action),calcite-action::slotted([slot=trigger]){position:relative;block-size:100%;flex:0 1 auto;align-self:stretch}.menu{flex-direction:column;flex-wrap:nowrap;outline:2px solid transparent;outline-offset:2px}:host([hidden]){display:none}[hidden]{display:none}\";\n\nconst SUPPORTED_MENU_NAV_KEYS = [\"ArrowUp\", \"ArrowDown\", \"End\", \"Home\"];\nconst ActionMenu = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.calciteActionMenuOpen = createEvent(this, \"calciteActionMenuOpen\", 6);\n    this.actionElements = [];\n    this.guid = `calcite-action-menu-${guid()}`;\n    this.menuId = `${this.guid}-menu`;\n    this.menuButtonId = `${this.guid}-menu-button`;\n    // --------------------------------------------------------------------------\n    //\n    //  Component Methods\n    //\n    // --------------------------------------------------------------------------\n    this.connectMenuButtonEl = () => {\n      const { menuButtonId, menuId, open, label } = this;\n      const menuButtonEl = this.slottedMenuButtonEl || this.defaultMenuButtonEl;\n      if (this.menuButtonEl === menuButtonEl) {\n        return;\n      }\n      this.disconnectMenuButtonEl();\n      this.menuButtonEl = menuButtonEl;\n      this.setTooltipReferenceElement();\n      if (!menuButtonEl) {\n        return;\n      }\n      menuButtonEl.active = open;\n      menuButtonEl.setAttribute(\"aria-controls\", menuId);\n      menuButtonEl.setAttribute(\"aria-expanded\", toAriaBoolean(open));\n      menuButtonEl.setAttribute(\"aria-haspopup\", \"true\");\n      if (!menuButtonEl.id) {\n        menuButtonEl.id = menuButtonId;\n      }\n      if (!menuButtonEl.label) {\n        menuButtonEl.label = label;\n      }\n      if (!menuButtonEl.text) {\n        menuButtonEl.text = label;\n      }\n      menuButtonEl.addEventListener(\"pointerdown\", this.menuButtonClick);\n      menuButtonEl.addEventListener(\"keydown\", this.menuButtonKeyDown);\n    };\n    this.disconnectMenuButtonEl = () => {\n      const { menuButtonEl } = this;\n      if (!menuButtonEl) {\n        return;\n      }\n      menuButtonEl.removeEventListener(\"pointerdown\", this.menuButtonClick);\n      menuButtonEl.removeEventListener(\"keydown\", this.menuButtonKeyDown);\n    };\n    this.setMenuButtonEl = (event) => {\n      const actions = event.target\n        .assignedElements({\n        flatten: true,\n      })\n        .filter((el) => el?.matches(\"calcite-action\"));\n      this.slottedMenuButtonEl = actions[0];\n      this.connectMenuButtonEl();\n    };\n    this.setDefaultMenuButtonEl = (el) => {\n      this.defaultMenuButtonEl = el;\n      this.connectMenuButtonEl();\n    };\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.handleCalciteActionClick = () => {\n      this.open = false;\n      this.setFocus();\n    };\n    this.menuButtonClick = (event) => {\n      if (!isPrimaryPointerButton(event)) {\n        return;\n      }\n      this.toggleOpen();\n    };\n    this.updateTooltip = (event) => {\n      const tooltips = event.target\n        .assignedElements({\n        flatten: true,\n      })\n        .filter((el) => el?.matches(\"calcite-tooltip\"));\n      this.tooltipEl = tooltips[0];\n      this.setTooltipReferenceElement();\n    };\n    this.setTooltipReferenceElement = () => {\n      const { tooltipEl, expanded, menuButtonEl, open } = this;\n      if (tooltipEl) {\n        tooltipEl.referenceElement = !expanded && !open ? menuButtonEl : null;\n      }\n    };\n    this.updateAction = (action, index) => {\n      const { guid, activeMenuItemIndex } = this;\n      const id = `${guid}-action-${index}`;\n      action.tabIndex = -1;\n      action.setAttribute(\"role\", \"menuitem\");\n      if (!action.id) {\n        action.id = id;\n      }\n      // data attribute is used to style the \"activeMenuItemIndex\" action using token focus styling.\n      action.toggleAttribute(activeAttr, index === activeMenuItemIndex);\n    };\n    this.updateActions = (actions) => {\n      actions?.forEach(this.updateAction);\n    };\n    this.handleDefaultSlotChange = (event) => {\n      const actions = event.target\n        .assignedElements({\n        flatten: true,\n      })\n        .filter((el) => el?.matches(\"calcite-action\"));\n      this.actionElements = actions;\n    };\n    this.menuButtonKeyDown = (event) => {\n      const { key } = event;\n      const { actionElements, activeMenuItemIndex, open } = this;\n      if (!actionElements.length) {\n        return;\n      }\n      if (isActivationKey(key)) {\n        event.preventDefault();\n        if (!open) {\n          this.toggleOpen();\n          return;\n        }\n        const action = actionElements[activeMenuItemIndex];\n        action ? action.click() : this.toggleOpen(false);\n      }\n      if (key === \"Tab\") {\n        this.open = false;\n        return;\n      }\n      if (key === \"Escape\") {\n        this.toggleOpen(false);\n        event.preventDefault();\n        return;\n      }\n      this.handleActionNavigation(event, key, actionElements);\n    };\n    this.handleActionNavigation = (event, key, actions) => {\n      if (!this.isValidKey(key, SUPPORTED_MENU_NAV_KEYS)) {\n        return;\n      }\n      event.preventDefault();\n      if (!this.open) {\n        this.toggleOpen();\n        if (key === \"Home\" || key === \"ArrowDown\") {\n          this.activeMenuItemIndex = 0;\n        }\n        if (key === \"End\" || key === \"ArrowUp\") {\n          this.activeMenuItemIndex = actions.length - 1;\n        }\n        return;\n      }\n      if (key === \"Home\") {\n        this.activeMenuItemIndex = 0;\n      }\n      if (key === \"End\") {\n        this.activeMenuItemIndex = actions.length - 1;\n      }\n      const currentIndex = this.activeMenuItemIndex;\n      if (key === \"ArrowUp\") {\n        this.activeMenuItemIndex = getRoundRobinIndex(Math.max(currentIndex - 1, -1), actions.length);\n      }\n      if (key === \"ArrowDown\") {\n        this.activeMenuItemIndex = getRoundRobinIndex(currentIndex + 1, actions.length);\n      }\n    };\n    this.toggleOpenEnd = () => {\n      this.setFocus();\n      this.el.removeEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n    };\n    this.toggleOpen = (value = !this.open) => {\n      this.el.addEventListener(\"calcitePopoverOpen\", this.toggleOpenEnd);\n      this.open = value;\n    };\n    this.appearance = \"solid\";\n    this.expanded = false;\n    this.flipPlacements = undefined;\n    this.label = undefined;\n    this.open = false;\n    this.overlayPositioning = \"absolute\";\n    this.placement = \"auto\";\n    this.scale = undefined;\n    this.menuButtonEl = undefined;\n    this.activeMenuItemIndex = -1;\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  // --------------------------------------------------------------------------\n  componentWillLoad() {\n    setUpLoadableComponent(this);\n  }\n  componentDidLoad() {\n    setComponentLoaded(this);\n  }\n  disconnectedCallback() {\n    this.disconnectMenuButtonEl();\n  }\n  expandedHandler() {\n    this.open = false;\n    this.setTooltipReferenceElement();\n  }\n  openHandler(open) {\n    this.activeMenuItemIndex = this.open ? 0 : -1;\n    if (this.menuButtonEl) {\n      this.menuButtonEl.active = open;\n    }\n    this.calciteActionMenuOpen.emit();\n    this.setTooltipReferenceElement();\n  }\n  closeCalciteActionMenuOnClick(event) {\n    if (!isPrimaryPointerButton(event)) {\n      return;\n    }\n    const composedPath = event.composedPath();\n    if (composedPath.includes(this.el)) {\n      return;\n    }\n    this.open = false;\n  }\n  activeMenuItemIndexHandler() {\n    this.updateActions(this.actionElements);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Methods\n  //\n  // --------------------------------------------------------------------------\n  /** Sets focus on the component. */\n  async setFocus() {\n    await componentFocusable(this);\n    return focusElement(this.menuButtonEl);\n  }\n  renderMenuButton() {\n    const { appearance, label, scale, expanded } = this;\n    const menuButtonSlot = (h(\"slot\", { name: SLOTS.trigger, onSlotchange: this.setMenuButtonEl }, h(\"calcite-action\", { appearance: appearance, class: CSS.defaultTrigger, icon: ICONS.menu, scale: scale, text: label, textEnabled: expanded,\n      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)\n      ref: this.setDefaultMenuButtonEl })));\n    return menuButtonSlot;\n  }\n  renderMenuItems() {\n    const { actionElements, activeMenuItemIndex, open, menuId, menuButtonEl, label, placement, overlayPositioning, flipPlacements, } = this;\n    const activeAction = actionElements[activeMenuItemIndex];\n    const activeDescendantId = activeAction?.id || null;\n    return (h(\"calcite-popover\", { flipPlacements: flipPlacements, focusTrapDisabled: true, label: label, offsetDistance: 0, open: open, overlayPositioning: overlayPositioning, placement: placement, pointerDisabled: true, referenceElement: menuButtonEl }, h(\"div\", { \"aria-activedescendant\": activeDescendantId, \"aria-labelledby\": menuButtonEl?.id, class: CSS.menu, id: menuId, onClick: this.handleCalciteActionClick, role: \"menu\", tabIndex: -1 }, h(\"slot\", { onSlotchange: this.handleDefaultSlotChange }))));\n  }\n  render() {\n    return (h(Fragment, null, this.renderMenuButton(), this.renderMenuItems(), h(\"slot\", { name: SLOTS.tooltip, onSlotchange: this.updateTooltip })));\n  }\n  isValidKey(key, supportedKeys) {\n    return !!supportedKeys.find((k) => k === key);\n  }\n  get el() { return this; }\n  static get watchers() { return {\n    \"expanded\": [\"expandedHandler\"],\n    \"open\": [\"openHandler\"],\n    \"activeMenuItemIndex\": [\"activeMenuItemIndexHandler\"]\n  }; }\n  static get style() { return actionMenuCss; }\n}, [1, \"calcite-action-menu\", {\n    \"appearance\": [513],\n    \"expanded\": [516],\n    \"flipPlacements\": [16],\n    \"label\": [1],\n    \"open\": [1540],\n    \"overlayPositioning\": [513, \"overlay-positioning\"],\n    \"placement\": [513],\n    \"scale\": [513],\n    \"menuButtonEl\": [32],\n    \"activeMenuItemIndex\": [32],\n    \"setFocus\": [64]\n  }, [[9, \"pointerdown\", \"closeCalciteActionMenuOnClick\"]]]);\nfunction defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"calcite-action-menu\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\", \"calcite-popover\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"calcite-action-menu\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, ActionMenu);\n      }\n      break;\n    case \"calcite-action\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$4();\n      }\n      break;\n    case \"calcite-icon\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$3();\n      }\n      break;\n    case \"calcite-loader\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$2();\n      }\n      break;\n    case \"calcite-popover\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$1();\n      }\n      break;\n  } });\n}\ndefineCustomElement();\n\nexport { ActionMenu as A, SLOTS as S, defineCustomElement as d };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\n/** Used for built-in method references. */\nvar objectProto$1 = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto$1.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString$1 = objectProto$1.toString;\n\n/** Built-in value references. */\nvar symToStringTag$1 = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag$1),\n      tag = value[symToStringTag$1];\n\n  try {\n    value[symToStringTag$1] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString$1.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag$1] = tag;\n    } else {\n      delete value[symToStringTag$1];\n    }\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\n/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport { Symbol as S, isSymbol as a, baseGetTag as b, isObjectLike as c, debounce as d, freeGlobal as f, isObject as i, root as r };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { readTask } from '@stencil/core/internal/client/index.js';\n\nfunction isOpen(component) {\n  return \"opened\" in component ? component.opened : component.open;\n}\nfunction emitImmediately(component, nonOpenCloseComponent = false) {\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n    ? component.onBeforeOpen()\n    : component.onBeforeClose();\n  (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n    ? component.onOpen()\n    : component.onClose();\n}\n/**\n * Helper to determine globally set transition duration on the given openTransitionProp, which is imported and set in the @Watch(\"open\").\n * Used to emit (before)open/close events both for when the opacity transition is present and when there is none (transition-duration is set to 0).\n *\n * @example\n * import { onToggleOpenCloseComponent, OpenCloseComponent } from \"../../utils/openCloseComponent\";\n *\n * async componentWillLoad() {\n * // When component initially renders, if `open` was set we need to trigger on load as watcher doesn't fire.\n * if (this.open) {\n *    onToggleOpenCloseComponent(this);\n * }\n * @Watch(\"open\")\n * async toggleModal(value: boolean): Promise<void> {\n *    onToggleOpenCloseComponent(this);\n * }\n *\n * @param component - OpenCloseComponent uses `open` prop to emit (before)open/close.\n * @param nonOpenCloseComponent - OpenCloseComponent uses `expanded` prop to emit (before)open/close.\n */\nfunction onToggleOpenCloseComponent(component, nonOpenCloseComponent = false) {\n  readTask(() => {\n    if (component.transitionEl) {\n      const { transitionDuration: allDurations, transitionProperty: allProps } = getComputedStyle(component.transitionEl);\n      const allTransitionDurationsArray = allDurations.split(\",\");\n      const allTransitionPropsArray = allProps.split(\",\");\n      const openTransitionPropIndex = allTransitionPropsArray.indexOf(component.openTransitionProp);\n      const transitionDuration = allTransitionDurationsArray[openTransitionPropIndex] ??\n        /* Safari will have a single transition value if multiple props share it,\n        so we fall back to it if there's no matching prop duration */\n        allTransitionDurationsArray[0];\n      if (transitionDuration === \"0s\") {\n        emitImmediately(component, nonOpenCloseComponent);\n        return;\n      }\n      const fallbackTimeoutId = setTimeout(() => {\n        component.transitionEl.removeEventListener(\"transitionstart\", onStart);\n        component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\n        component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\n        emitImmediately(component, nonOpenCloseComponent);\n      }, parseFloat(transitionDuration) * 1000);\n      component.transitionEl.addEventListener(\"transitionstart\", onStart);\n      component.transitionEl.addEventListener(\"transitionend\", onEndOrCancel);\n      component.transitionEl.addEventListener(\"transitioncancel\", onEndOrCancel);\n      function onStart(event) {\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\n          clearTimeout(fallbackTimeoutId);\n          component.transitionEl.removeEventListener(\"transitionstart\", onStart);\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n            ? component.onBeforeOpen()\n            : component.onBeforeClose();\n        }\n      }\n      function onEndOrCancel(event) {\n        if (event.propertyName === component.openTransitionProp && event.target === component.transitionEl) {\n          (nonOpenCloseComponent ? component[component.transitionProp] : isOpen(component))\n            ? component.onOpen()\n            : component.onClose();\n          component.transitionEl.removeEventListener(\"transitionend\", onEndOrCancel);\n          component.transitionEl.removeEventListener(\"transitioncancel\", onEndOrCancel);\n        }\n      }\n    }\n  });\n}\n\nexport { onToggleOpenCloseComponent as o };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { Build } from '@stencil/core/internal/client/index.js';\nimport { b as getElementDir } from './dom.js';\nimport { d as debounce } from './debounce.js';\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  return {\n    ...rect,\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  };\n}\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain positioning strategy.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition$1 = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    ...rects.floating,\n    x,\n    y\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center != offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== 'none') {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$map$so;\n                const placement = (_overflowsData$map$so = overflowsData.map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: diffCoords\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null ? void 0 : (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const webkit = isWebKit();\n  const css = getComputedStyle$1(element);\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle$1(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentIFrame = win.frameElement;\n    while (currentIFrame && offsetParent && offsetWin !== win) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle$1(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentIFrame = getWindow(currentIFrame).frameElement;\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== 'fixed') {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle$1(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  return getCssDimensions(element);\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const window = getWindow(element);\n  if (!isHTMLElement(element)) {\n    return window;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static' && !isContainingBlock(offsetParent))) {\n    return window;\n  }\n  return offsetParent || getContainingBlock(element) || window;\n}\n\nconst getElementRects = async function (_ref) {\n  let {\n    reference,\n    floating,\n    strategy\n  } = _ref;\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  return {\n    reference: getRectRelativeToOffsetParent(reference, await getOffsetParentFn(floating), strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      ...(await getDimensionsFn(floating))\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle$1(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    clearTimeout(timeoutId);\n    io && io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 100);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          resizeObserver && resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo && cleanupIo();\n    resizeObserver && resizeObserver.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a reference element when it is given a certain CSS positioning\n * strategy.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\n/* eslint-disable @typescript-eslint/ban-types */\nfunction offsetParent(element) {\n    return offsetParentPolyfill(element);\n}\nfunction flatTreeParent(element) {\n    if (element.assignedSlot) {\n        return element.assignedSlot;\n    }\n    if (element.parentNode instanceof ShadowRoot) {\n        return element.parentNode.host;\n    }\n    return element.parentNode;\n}\nfunction offsetParentPolyfill(element) {\n    // Do an initial walk to check for display:none ancestors.\n    for (let ancestor = element; ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        if (getComputedStyle(ancestor).display === 'none') {\n            return null;\n        }\n    }\n    for (let ancestor = flatTreeParent(element); ancestor; ancestor = flatTreeParent(ancestor)) {\n        if (!(ancestor instanceof Element)) {\n            continue;\n        }\n        const style = getComputedStyle(ancestor);\n        // Display:contents nodes aren't in the layout tree so they should be skipped.\n        if (style.display === 'contents') {\n            continue;\n        }\n        if (style.position !== 'static' || style.filter !== 'none') {\n            return ancestor;\n        }\n        if (ancestor.tagName === 'BODY') {\n            return ancestor;\n        }\n    }\n    return null;\n}\n\n(function setUpFloatingUiForShadowDomPositioning() {\n  if (Build.isBrowser) {\n    const originalGetOffsetParent = platform.getOffsetParent;\n    platform.getOffsetParent = (element) => originalGetOffsetParent(element, offsetParent);\n  }\n})();\n/**\n * Positions the floating element relative to the reference element.\n *\n * **Note:** exported for testing purposes only\n *\n * @param root0\n * @param root0.referenceEl\n * @param root0.floatingEl\n * @param root0.overlayPositioning\n * @param root0.placement\n * @param root0.flipDisabled\n * @param root0.flipPlacements\n * @param root0.offsetDistance\n * @param root0.offsetSkidding\n * @param root0.arrowEl\n * @param root0.type\n * @param component\n * @param root0.referenceEl.referenceEl\n * @param root0.referenceEl.floatingEl\n * @param root0.referenceEl.overlayPositioning\n * @param root0.referenceEl.placement\n * @param root0.referenceEl.flipDisabled\n * @param root0.referenceEl.flipPlacements\n * @param root0.referenceEl.offsetDistance\n * @param root0.referenceEl.offsetSkidding\n * @param root0.referenceEl.arrowEl\n * @param root0.referenceEl.type\n * @param component.referenceEl\n * @param component.floatingEl\n * @param component.overlayPositioning\n * @param component.placement\n * @param component.flipDisabled\n * @param component.flipPlacements\n * @param component.offsetDistance\n * @param component.offsetSkidding\n * @param component.arrowEl\n * @param component.type\n */\nconst positionFloatingUI = \n/* we export arrow function to allow us to spy on it during testing */\nasync (component, { referenceEl, floatingEl, overlayPositioning = \"absolute\", placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type, }) => {\n  if (!referenceEl || !floatingEl) {\n    return null;\n  }\n  const { x, y, placement: effectivePlacement, strategy: position, middlewareData, } = await computePosition(referenceEl, floatingEl, {\n    strategy: overlayPositioning,\n    placement: placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\"\n      ? undefined\n      : getEffectivePlacement(floatingEl, placement),\n    middleware: getMiddleware({\n      placement,\n      flipDisabled,\n      flipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type,\n    }),\n  });\n  if (arrowEl && middlewareData.arrow) {\n    const { x, y } = middlewareData.arrow;\n    const side = effectivePlacement.split(\"-\")[0];\n    const alignment = x != null ? \"left\" : \"top\";\n    const transform = ARROW_CSS_TRANSFORM[side];\n    const reset = { left: \"\", top: \"\", bottom: \"\", right: \"\" };\n    if (\"floatingLayout\" in component) {\n      component.floatingLayout = side === \"left\" || side === \"right\" ? \"horizontal\" : \"vertical\";\n    }\n    Object.assign(arrowEl.style, {\n      ...reset,\n      [alignment]: `${alignment == \"left\" ? x : y}px`,\n      [side]: \"100%\",\n      transform,\n    });\n  }\n  const referenceHidden = middlewareData.hide?.referenceHidden;\n  const visibility = referenceHidden ? \"hidden\" : null;\n  const pointerEvents = visibility ? \"none\" : null;\n  floatingEl.setAttribute(placementDataAttribute, effectivePlacement);\n  const transform = `translate(${Math.round(x)}px,${Math.round(y)}px)`;\n  Object.assign(floatingEl.style, {\n    visibility,\n    pointerEvents,\n    position,\n    top: \"0\",\n    left: \"0\",\n    transform,\n  });\n};\n/**\n * Exported for testing purposes only\n */\nconst placementDataAttribute = \"data-placement\";\n/**\n * Exported for testing purposes only\n */\nconst repositionDebounceTimeout = 100;\nconst effectivePlacements = [\n  \"top\",\n  \"bottom\",\n  \"right\",\n  \"left\",\n  \"top-start\",\n  \"top-end\",\n  \"bottom-start\",\n  \"bottom-end\",\n  \"right-start\",\n  \"right-end\",\n  \"left-start\",\n  \"left-end\",\n];\nconst defaultMenuPlacement = \"bottom-start\";\nconst FloatingCSS = {\n  animation: \"calcite-floating-ui-anim\",\n  animationActive: \"calcite-floating-ui-anim--active\",\n};\nfunction getMiddleware({ placement, flipDisabled, flipPlacements, offsetDistance, offsetSkidding, arrowEl, type, }) {\n  const defaultMiddleware = [shift(), hide()];\n  if (type === \"menu\") {\n    return [\n      ...defaultMiddleware,\n      flip({\n        fallbackPlacements: flipPlacements || [\"top-start\", \"top\", \"top-end\", \"bottom-start\", \"bottom\", \"bottom-end\"],\n      }),\n    ];\n  }\n  if (type === \"popover\" || type === \"tooltip\") {\n    const middleware = [\n      ...defaultMiddleware,\n      offset({\n        mainAxis: typeof offsetDistance === \"number\" ? offsetDistance : 0,\n        crossAxis: typeof offsetSkidding === \"number\" ? offsetSkidding : 0,\n      }),\n    ];\n    if (placement === \"auto\" || placement === \"auto-start\" || placement === \"auto-end\") {\n      middleware.push(autoPlacement({ alignment: placement === \"auto-start\" ? \"start\" : placement === \"auto-end\" ? \"end\" : null }));\n    }\n    else if (!flipDisabled) {\n      middleware.push(flip(flipPlacements ? { fallbackPlacements: flipPlacements } : {}));\n    }\n    if (arrowEl) {\n      middleware.push(arrow({\n        element: arrowEl,\n      }));\n    }\n    return middleware;\n  }\n  return [];\n}\nfunction filterComputedPlacements(placements, el) {\n  const filteredPlacements = placements.filter((placement) => effectivePlacements.includes(placement));\n  if (filteredPlacements.length !== placements.length) {\n    console.warn(`${el.tagName}: Invalid value found in: flipPlacements. Try any of these: ${effectivePlacements\n      .map((placement) => `\"${placement}\"`)\n      .join(\", \")\n      .trim()}`, { el });\n  }\n  return filteredPlacements;\n}\nfunction getEffectivePlacement(floatingEl, placement) {\n  const placements = [\"left\", \"right\"];\n  if (getElementDir(floatingEl) === \"rtl\") {\n    placements.reverse();\n  }\n  return placement.replace(/leading/gi, placements[0]).replace(/trailing/gi, placements[1]);\n}\n/**\n * Convenience function to manage `reposition` calls for FloatingUIComponents that use `positionFloatingUI.\n *\n * Note: this is not needed for components that use `calcite-popover`.\n *\n * @param component - A floating-ui component.\n * @param options - Reposition parameters.\n * @param options.referenceEl - The `referenceElement` used to position the component according to its `placement` value.\n * @param options.floatingEl - The `floatingElement` containing the floating ui.\n * @param options.overlayPositioning - type of positioning to use for the overlaid content.\n * @param options.placement - Determines where the component will be positioned relative to the `referenceElement`.\n * @param options.flipDisabled - Prevents flipping the component's placement when overlapping its `referenceElement`.\n * @param options.flipPlacements - Defines the available placements that can be used when a flip occurs.\n * @param options.offsetDistance - Offsets the position of the popover away from the `referenceElement`.\n * @param options.offsetSkidding - Offsets the position of the component along the `referenceElement`.\n * @param options.arrowEl - A customizable arrow element.\n * @param options.type - The type of floating UI.\n * @param delayed - Reposition the component after a delay.\n * @returns {Promise<void>}\n */\nasync function reposition(component, options, delayed = false) {\n  const positionFunction = delayed ? getDebouncedReposition(component) : positionFloatingUI;\n  return positionFunction(component, options);\n}\nfunction getDebouncedReposition(component) {\n  let debounced = componentToDebouncedRepositionMap.get(component);\n  if (debounced) {\n    return debounced;\n  }\n  debounced = debounce(positionFloatingUI, repositionDebounceTimeout, {\n    leading: true,\n    maxWait: repositionDebounceTimeout,\n  });\n  componentToDebouncedRepositionMap.set(component, debounced);\n  return debounced;\n}\nconst ARROW_CSS_TRANSFORM = {\n  top: \"\",\n  left: \"rotate(-90deg)\",\n  bottom: \"rotate(180deg)\",\n  right: \"rotate(90deg)\",\n};\n/**\n * Exported for testing purposes only\n *\n * @internal\n */\nconst cleanupMap = new WeakMap();\nconst componentToDebouncedRepositionMap = new WeakMap();\n/**\n * Helper to set up floating element interactions on connectedCallback.\n *\n * @param component - A floating-ui component.\n * @param referenceEl - The `referenceElement` used to position the component according to its `placement` value.\n * @param floatingEl - The `floatingElement` containing the floating ui.\n */\nfunction connectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  disconnectFloatingUI(component, referenceEl, floatingEl);\n  Object.assign(floatingEl.style, {\n    visibility: \"hidden\",\n    pointerEvents: \"none\",\n    // initial positioning based on https://floating-ui.com/docs/computePosition#initial-layout\n    position: component.overlayPositioning,\n    top: \"0\",\n    left: \"0\",\n  });\n  const runAutoUpdate = Build.isBrowser\n    ? autoUpdate\n    : (_refEl, _floatingEl, updateCallback) => {\n      updateCallback();\n      return () => {\n        /* noop */\n      };\n    };\n  cleanupMap.set(component, runAutoUpdate(referenceEl, floatingEl, () => component.reposition()));\n}\n/**\n * Helper to tear down floating element interactions on disconnectedCallback.\n *\n * @param component - A floating-ui component.\n * @param referenceEl - The `referenceElement` used to position the component according to its `placement` value.\n * @param floatingEl - The `floatingElement` containing the floating ui.\n */\nfunction disconnectFloatingUI(component, referenceEl, floatingEl) {\n  if (!floatingEl || !referenceEl) {\n    return;\n  }\n  cleanupMap.get(component)?.();\n  cleanupMap.delete(component);\n  componentToDebouncedRepositionMap.get(component)?.cancel();\n  componentToDebouncedRepositionMap.delete(component);\n}\nconst visiblePointerSize = 4;\n/**\n * Default offset the position of the floating element away from the reference element.\n *\n * @default 6\n */\nconst defaultOffsetDistance = Math.ceil(Math.hypot(visiblePointerSize, visiblePointerSize));\n\nexport { FloatingCSS as F, disconnectFloatingUI as a, defaultOffsetDistance as b, connectFloatingUI as c, defaultMenuPlacement as d, filterComputedPlacements as f, reposition as r };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { z as tabbable, A as focusable, B as isTabbable, D as getTabIndex, E as isFocusable, k as focusElement, F as tabbableOptions } from './dom.js';\n\n/*!\n* focus-trap 7.5.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _toPrimitive(input, hint) {\n  if (typeof input !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (typeof res !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n  var key = _toPrimitive(arg, \"string\");\n  return typeof key === \"symbol\" ? key : String(key);\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap.pause();\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0) {\n      trapStack[trapStack.length - 1].unpause();\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n// Array.find/findIndex() are not supported on IE; this replicates enough\n//  of Array.findIndex() for our needs\nvar findIndex = function findIndex(arr, fn) {\n  var idx = -1;\n  arr.every(function (value, i) {\n    if (fn(value)) {\n      idx = i;\n      return false; // break\n    }\n\n    return true; // next\n  });\n\n  return idx;\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(void 0, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || ( // fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @returns {undefined | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `false` if the option\n   *  resolved to `false` (node explicitly not given); otherwise, the resolved\n   *  DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        params[_key2 - 1] = arguments[_key2];\n      }\n      optionValue = optionValue.apply(void 0, params);\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      if (!node) {\n        throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus');\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', previousActiveElement);\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref2) {\n    var target = _ref2.target,\n      event = _ref2.event,\n      _ref2$isBackward = _ref2.isBackward,\n      isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = findIndex(state.tabbableGroups, function (_ref3) {\n          var firstTabbableNode = _ref3.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = findIndex(state.tabbableGroups, function (_ref4) {\n          var lastTabbableNode = _ref4.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        tryFocus(nextNode);\n      } else {\n        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n\n  var checkKey = function checkKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n      return;\n    }\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      tryFocus(getInitialFocusNode());\n    }) : tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkKey, {\n      capture: true,\n      passive: false\n    });\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkKey, true);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === void 0 || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === void 0 || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === void 0 || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (state.paused || !state.active) {\n        return this;\n      }\n      var onPause = getOption(pauseOptions, 'onPause');\n      var onPostPause = getOption(pauseOptions, 'onPostPause');\n      state.paused = true;\n      onPause === null || onPause === void 0 || onPause();\n      removeListeners();\n      updateObservedNodes();\n      onPostPause === null || onPostPause === void 0 || onPostPause();\n      return this;\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.paused || !state.active) {\n        return this;\n      }\n      var onUnpause = getOption(unpauseOptions, 'onUnpause');\n      var onPostUnpause = getOption(unpauseOptions, 'onPostUnpause');\n      state.paused = false;\n      onUnpause === null || onUnpause === void 0 || onUnpause();\n      updateTabbableNodes();\n      addListeners();\n      updateObservedNodes();\n      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();\n      return this;\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\n/**\n * This module allows custom configuration for components.\n */\nconst customConfig = globalThis[\"calciteConfig\"];\nconst focusTrapStack = customConfig?.focusTrapStack || [];\n\n/**\n * Helper to set up the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param options\n */\nfunction connectFocusTrap(component, options) {\n  const { el } = component;\n  const focusTrapNode = options?.focusTrapEl || el;\n  if (!focusTrapNode) {\n    return;\n  }\n  const focusTrapOptions = {\n    clickOutsideDeactivates: true,\n    escapeDeactivates: false,\n    fallbackFocus: focusTrapNode,\n    setReturnFocus: (el) => {\n      focusElement(el);\n      return false;\n    },\n    ...options?.focusTrapOptions,\n    // the following options are not overridable\n    document: el.ownerDocument,\n    tabbableOptions,\n    trapStack: focusTrapStack,\n  };\n  component.focusTrap = createFocusTrap(focusTrapNode, focusTrapOptions);\n}\n/**\n * Helper to activate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap activate options.\n */\nfunction activateFocusTrap(component, options) {\n  if (!component.focusTrapDisabled) {\n    component.focusTrap?.activate(options);\n  }\n}\n/**\n * Helper to deactivate the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @param [options] The FocusTrap deactivate options.\n */\nfunction deactivateFocusTrap(component, options) {\n  component.focusTrap?.deactivate(options);\n}\n/**\n * Helper to update the element(s) that are used within the FocusTrap component.\n *\n * @param {FocusTrapComponent} component The FocusTrap component.\n * @example\n * const modal = document.querySelector(\"calcite-modal\");\n * const input = document.createElement(\"calcite-input\");\n * content.appendChild(input);\n * await input.componentOnReady();\n * await modal.updateFocusTrapElements();\n * requestAnimationFrame(() => input.setFocus());\n */\nfunction updateFocusTrapElements(component) {\n  component.focusTrap?.updateContainerElements(component.el);\n}\n\nexport { activateFocusTrap as a, connectFocusTrap as c, deactivateFocusTrap as d, updateFocusTrapElements as u };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { h } from '@stencil/core/internal/client/index.js';\n\nconst CSS = {\n  arrow: \"calcite-floating-ui-arrow\",\n  arrowStroke: \"calcite-floating-ui-arrow__stroke\",\n};\nconst DEFAULTS = {\n  width: 12,\n  height: 6,\n  strokeWidth: 1,\n};\n/**\n * Renders a SVG element to be used as a floating-ui arrow.\n *\n * This functional component should be rendered inside a `FloatingUIComponent` when it needs an arrow element.\n *\n * @param floatingLayout.floatingLayout\n * @param floatingLayout  The effective floating layout to render the arrow vertically or horizontally. Possible values: `vertical` or `horizontal`.\n *\n * See [floating-ui](https://github.com/Esri/calcite-design-system/blob/main/src/utils/floating-ui.ts)\n * @param floatingLayout.key\n * @param floatingLayout.ref\n */\nconst FloatingArrow = ({ floatingLayout, key, ref, }) => {\n  const { width, height, strokeWidth } = DEFAULTS;\n  const svgX = width / 2;\n  const isVertical = floatingLayout === \"vertical\";\n  const dValue = \"M0,0\" +\n    ` H${width}` +\n    ` L${width - svgX},${height}` +\n    ` Q${svgX},${height} ${svgX},${height}` +\n    \" Z\";\n  return (h(\"svg\", { \"aria-hidden\": \"true\", class: CSS.arrow, height: width, key: key, viewBox: `0 0 ${width} ${width + (!isVertical ? strokeWidth : 0)}`, width: width + (isVertical ? strokeWidth : 0), \n    // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)\n    ref: ref },\n    strokeWidth > 0 && (h(\"path\", { class: CSS.arrowStroke, d: dValue, fill: \"none\", \"stroke-width\": strokeWidth + 1 })),\n    h(\"path\", { d: dValue, stroke: \"none\" })));\n};\n\nexport { FloatingArrow as F };\n","/*!\n * All material copyright ESRI, All Rights Reserved, unless otherwise specified.\n * See https://github.com/Esri/calcite-design-system/blob/main/LICENSE.md for details.\n * v1.11.0\n */\nimport { proxyCustomElement, HTMLElement, createEvent, forceUpdate, h, Host } from '@stencil/core/internal/client/index.js';\nimport { f as filterComputedPlacements, c as connectFloatingUI, b as defaultOffsetDistance, a as disconnectFloatingUI, r as reposition, F as FloatingCSS } from './floating-ui.js';\nimport { d as deactivateFocusTrap, a as activateFocusTrap, c as connectFocusTrap, u as updateFocusTrapElements } from './focusTrapComponent.js';\nimport { j as isPrimaryPointerButton, t as toAriaBoolean, f as focusFirstTabbable, q as queryElementRoots } from './dom.js';\nimport { g as guid } from './guid.js';\nimport { o as onToggleOpenCloseComponent } from './openCloseComponent.js';\nimport { H as Heading } from './Heading.js';\nimport { c as connectLocalized, d as disconnectLocalized } from './locale.js';\nimport { u as updateMessages, c as connectMessages, s as setUpMessages, d as disconnectMessages } from './t9n.js';\nimport { i as isActivationKey } from './key.js';\nimport { a as setUpLoadableComponent, s as setComponentLoaded, c as componentFocusable } from './loadable.js';\nimport { c as createObserver } from './observers.js';\nimport { F as FloatingArrow } from './FloatingArrow.js';\nimport { g as getIconScale } from './component.js';\nimport { d as defineCustomElement$3 } from './action.js';\nimport { d as defineCustomElement$2 } from './icon.js';\nimport { d as defineCustomElement$1 } from './loader.js';\n\nconst CSS = {\n  container: \"container\",\n  imageContainer: \"image-container\",\n  closeButtonContainer: \"close-button-container\",\n  closeButton: \"close-button\",\n  content: \"content\",\n  hasHeader: \"has-header\",\n  header: \"header\",\n  headerContent: \"header-content\",\n  heading: \"heading\",\n};\nconst defaultPopoverPlacement = \"auto\";\nconst ARIA_CONTROLS = \"aria-controls\";\nconst ARIA_EXPANDED = \"aria-expanded\";\n\nclass PopoverManager {\n  constructor() {\n    // --------------------------------------------------------------------------\n    //\n    //  Private Properties\n    //\n    // --------------------------------------------------------------------------\n    this.registeredElements = new Map();\n    this.registeredElementCount = 0;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.queryPopover = (composedPath) => {\n      const { registeredElements } = this;\n      const registeredElement = composedPath.find((pathEl) => registeredElements.has(pathEl));\n      return registeredElements.get(registeredElement);\n    };\n    this.togglePopovers = (event) => {\n      const composedPath = event.composedPath();\n      const togglePopover = this.queryPopover(composedPath);\n      if (togglePopover && !togglePopover.triggerDisabled) {\n        togglePopover.open = !togglePopover.open;\n      }\n      Array.from(this.registeredElements.values())\n        .filter((popover) => popover !== togglePopover && popover.autoClose && popover.open && !composedPath.includes(popover))\n        .forEach((popover) => (popover.open = false));\n    };\n    this.keyHandler = (event) => {\n      if (event.defaultPrevented) {\n        return;\n      }\n      if (event.key === \"Escape\") {\n        this.closeAllPopovers();\n      }\n      else if (isActivationKey(event.key)) {\n        this.togglePopovers(event);\n      }\n    };\n    this.clickHandler = (event) => {\n      if (isPrimaryPointerButton(event)) {\n        this.togglePopovers(event);\n      }\n    };\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  registerElement(referenceEl, popover) {\n    this.registeredElementCount++;\n    this.registeredElements.set(referenceEl, popover);\n    if (this.registeredElementCount === 1) {\n      this.addListeners();\n    }\n  }\n  unregisterElement(referenceEl) {\n    if (this.registeredElements.delete(referenceEl)) {\n      this.registeredElementCount--;\n    }\n    if (this.registeredElementCount === 0) {\n      this.removeListeners();\n    }\n  }\n  closeAllPopovers() {\n    Array.from(this.registeredElements.values()).forEach((popover) => (popover.open = false));\n  }\n  addListeners() {\n    document.addEventListener(\"pointerdown\", this.clickHandler, { capture: true });\n    document.addEventListener(\"keydown\", this.keyHandler, { capture: true });\n  }\n  removeListeners() {\n    document.removeEventListener(\"pointerdown\", this.clickHandler, { capture: true });\n    document.removeEventListener(\"keydown\", this.keyHandler, { capture: true });\n  }\n}\n\nconst popoverCss = \":host{--calcite-floating-ui-z-index:var(--calcite-popover-z-index, var(--calcite-app-z-index-popup));display:block;position:absolute;z-index:var(--calcite-floating-ui-z-index)}.calcite-floating-ui-anim{position:relative;transition:var(--calcite-floating-ui-transition);transition-property:transform, visibility, opacity;opacity:0;box-shadow:0 0 16px 0 rgba(0, 0, 0, 0.16);z-index:var(--calcite-app-z-index);border-radius:0.25rem}:host([data-placement^=bottom]) .calcite-floating-ui-anim{transform:translateY(-5px)}:host([data-placement^=top]) .calcite-floating-ui-anim{transform:translateY(5px)}:host([data-placement^=left]) .calcite-floating-ui-anim{transform:translateX(5px)}:host([data-placement^=right]) .calcite-floating-ui-anim{transform:translateX(-5px)}:host([data-placement]) .calcite-floating-ui-anim--active{opacity:1;transform:translate(0)}:host([calcite-hydrated-hidden]){visibility:hidden !important;pointer-events:none}.calcite-floating-ui-arrow{pointer-events:none;position:absolute;z-index:calc(var(--calcite-app-z-index) * -1);fill:var(--calcite-ui-foreground-1)}.calcite-floating-ui-arrow__stroke{stroke:var(--calcite-ui-border-3)}:host([scale=s]) .heading{padding-inline:0.75rem;padding-block:0.5rem;font-size:var(--calcite-font-size--1);line-height:1.375}:host([scale=m]) .heading{padding-inline:1rem;padding-block:0.75rem;font-size:var(--calcite-font-size-0);line-height:1.375}:host([scale=l]) .heading{padding-inline:1.25rem;padding-block:1rem;font-size:var(--calcite-font-size-1);line-height:1.375}:host{pointer-events:none}:host([open]){pointer-events:initial}.calcite-floating-ui-anim{border-radius:0.25rem;border-width:1px;border-style:solid;border-color:var(--calcite-ui-border-3);background-color:var(--calcite-ui-foreground-1)}.arrow::before{outline:1px solid var(--calcite-ui-border-3)}.header{display:flex;flex:1 1 auto;align-items:stretch;justify-content:flex-start;border-width:0px;border-block-end-width:1px;border-style:solid;border-block-end-color:var(--calcite-ui-border-3)}.heading{margin:0px;display:block;flex:1 1 auto;align-self:center;white-space:normal;font-weight:var(--calcite-font-weight-medium);color:var(--calcite-ui-text-1);word-wrap:break-word;word-break:break-word}.container{position:relative;display:flex;block-size:100%;flex-direction:row;flex-wrap:nowrap;border-radius:0.25rem;color:var(--calcite-ui-text-1)}.container.has-header{flex-direction:column}.content{display:flex;block-size:100%;inline-size:100%;flex-direction:column;flex-wrap:nowrap;align-self:center;word-wrap:break-word;word-break:break-word}.close-button-container{display:flex;overflow:hidden;flex:0 0 auto;border-start-end-radius:0.25rem;border-end-end-radius:0.25rem}::slotted(calcite-panel),::slotted(calcite-flow){block-size:100%}:host([hidden]){display:none}[hidden]{display:none}\";\n\nconst manager = new PopoverManager();\nconst Popover = /*@__PURE__*/ proxyCustomElement(class extends HTMLElement {\n  constructor() {\n    super();\n    this.__registerHost();\n    this.__attachShadow();\n    this.calcitePopoverBeforeClose = createEvent(this, \"calcitePopoverBeforeClose\", 6);\n    this.calcitePopoverClose = createEvent(this, \"calcitePopoverClose\", 6);\n    this.calcitePopoverBeforeOpen = createEvent(this, \"calcitePopoverBeforeOpen\", 6);\n    this.calcitePopoverOpen = createEvent(this, \"calcitePopoverOpen\", 6);\n    this.mutationObserver = createObserver(\"mutation\", () => this.updateFocusTrapElements());\n    this.guid = `calcite-popover-${guid()}`;\n    this.openTransitionProp = \"opacity\";\n    this.hasLoaded = false;\n    // --------------------------------------------------------------------------\n    //\n    //  Private Methods\n    //\n    // --------------------------------------------------------------------------\n    this.setTransitionEl = (el) => {\n      this.transitionEl = el;\n    };\n    this.setFilteredPlacements = () => {\n      const { el, flipPlacements } = this;\n      this.filteredFlipPlacements = flipPlacements\n        ? filterComputedPlacements(flipPlacements, el)\n        : null;\n    };\n    this.setUpReferenceElement = (warn = true) => {\n      this.removeReferences();\n      this.effectiveReferenceElement = this.getReferenceElement();\n      connectFloatingUI(this, this.effectiveReferenceElement, this.el);\n      const { el, referenceElement, effectiveReferenceElement } = this;\n      if (warn && referenceElement && !effectiveReferenceElement) {\n        console.warn(`${el.tagName}: reference-element id \"${referenceElement}\" was not found.`, {\n          el,\n        });\n      }\n      this.addReferences();\n    };\n    this.getId = () => {\n      return this.el.id || this.guid;\n    };\n    this.setExpandedAttr = () => {\n      const { effectiveReferenceElement, open } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      if (\"setAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.setAttribute(ARIA_EXPANDED, toAriaBoolean(open));\n      }\n    };\n    this.addReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      const id = this.getId();\n      if (\"setAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.setAttribute(ARIA_CONTROLS, id);\n      }\n      manager.registerElement(effectiveReferenceElement, this.el);\n      this.setExpandedAttr();\n    };\n    this.removeReferences = () => {\n      const { effectiveReferenceElement } = this;\n      if (!effectiveReferenceElement) {\n        return;\n      }\n      if (\"removeAttribute\" in effectiveReferenceElement) {\n        effectiveReferenceElement.removeAttribute(ARIA_CONTROLS);\n        effectiveReferenceElement.removeAttribute(ARIA_EXPANDED);\n      }\n      manager.unregisterElement(effectiveReferenceElement);\n    };\n    this.hide = () => {\n      this.open = false;\n    };\n    this.storeArrowEl = (el) => {\n      this.arrowEl = el;\n      this.reposition(true);\n    };\n    this.autoClose = false;\n    this.closable = false;\n    this.flipDisabled = false;\n    this.focusTrapDisabled = false;\n    this.pointerDisabled = false;\n    this.flipPlacements = undefined;\n    this.heading = undefined;\n    this.headingLevel = undefined;\n    this.label = undefined;\n    this.messageOverrides = undefined;\n    this.messages = undefined;\n    this.offsetDistance = defaultOffsetDistance;\n    this.offsetSkidding = 0;\n    this.open = false;\n    this.overlayPositioning = \"absolute\";\n    this.placement = defaultPopoverPlacement;\n    this.referenceElement = undefined;\n    this.scale = \"m\";\n    this.triggerDisabled = false;\n    this.effectiveLocale = \"\";\n    this.floatingLayout = \"vertical\";\n    this.effectiveReferenceElement = undefined;\n    this.defaultMessages = undefined;\n  }\n  handleFocusTrapDisabled(focusTrapDisabled) {\n    if (!this.open) {\n      return;\n    }\n    focusTrapDisabled ? deactivateFocusTrap(this) : activateFocusTrap(this);\n  }\n  flipPlacementsHandler() {\n    this.setFilteredPlacements();\n    this.reposition(true);\n  }\n  onMessagesChange() {\n    /* wired up by t9n util */\n  }\n  offsetDistanceOffsetHandler() {\n    this.reposition(true);\n  }\n  offsetSkiddingHandler() {\n    this.reposition(true);\n  }\n  openHandler(value) {\n    onToggleOpenCloseComponent(this);\n    if (value) {\n      this.reposition(true);\n    }\n    this.setExpandedAttr();\n  }\n  overlayPositioningHandler() {\n    this.reposition(true);\n  }\n  placementHandler() {\n    this.reposition(true);\n  }\n  referenceElementHandler() {\n    this.setUpReferenceElement();\n    this.reposition(true);\n  }\n  effectiveLocaleChange() {\n    updateMessages(this, this.effectiveLocale);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Lifecycle\n  //\n  // --------------------------------------------------------------------------\n  connectedCallback() {\n    this.setFilteredPlacements();\n    connectLocalized(this);\n    connectMessages(this);\n    this.setUpReferenceElement(this.hasLoaded);\n    connectFocusTrap(this);\n    if (this.open) {\n      onToggleOpenCloseComponent(this);\n    }\n  }\n  async componentWillLoad() {\n    await setUpMessages(this);\n    setUpLoadableComponent(this);\n  }\n  componentDidLoad() {\n    setComponentLoaded(this);\n    if (this.referenceElement && !this.effectiveReferenceElement) {\n      this.setUpReferenceElement();\n    }\n    this.reposition();\n    this.hasLoaded = true;\n  }\n  disconnectedCallback() {\n    this.removeReferences();\n    disconnectLocalized(this);\n    disconnectMessages(this);\n    disconnectFloatingUI(this, this.effectiveReferenceElement, this.el);\n    deactivateFocusTrap(this);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Public Methods\n  //\n  // --------------------------------------------------------------------------\n  /**\n   * Updates the position of the component.\n   *\n   * @param delayed\n   */\n  async reposition(delayed = false) {\n    const { el, effectiveReferenceElement, placement, overlayPositioning, flipDisabled, filteredFlipPlacements, offsetDistance, offsetSkidding, arrowEl, } = this;\n    return reposition(this, {\n      floatingEl: el,\n      referenceEl: effectiveReferenceElement,\n      overlayPositioning,\n      placement,\n      flipDisabled,\n      flipPlacements: filteredFlipPlacements,\n      offsetDistance,\n      offsetSkidding,\n      arrowEl,\n      type: \"popover\",\n    }, delayed);\n  }\n  /**\n   * Sets focus on the component's first focusable element.\n   */\n  async setFocus() {\n    await componentFocusable(this);\n    forceUpdate(this.el);\n    focusFirstTabbable(this.el);\n  }\n  /**\n   * Updates the element(s) that are used within the focus-trap of the component.\n   */\n  async updateFocusTrapElements() {\n    updateFocusTrapElements(this);\n  }\n  getReferenceElement() {\n    const { referenceElement, el } = this;\n    return ((typeof referenceElement === \"string\"\n      ? queryElementRoots(el, { id: referenceElement })\n      : referenceElement) || null);\n  }\n  onBeforeOpen() {\n    this.calcitePopoverBeforeOpen.emit();\n  }\n  onOpen() {\n    this.calcitePopoverOpen.emit();\n    activateFocusTrap(this);\n  }\n  onBeforeClose() {\n    this.calcitePopoverBeforeClose.emit();\n  }\n  onClose() {\n    this.calcitePopoverClose.emit();\n    deactivateFocusTrap(this);\n  }\n  // --------------------------------------------------------------------------\n  //\n  //  Render Methods\n  //\n  // --------------------------------------------------------------------------\n  renderCloseButton() {\n    const { messages, closable } = this;\n    return closable ? (h(\"div\", { class: CSS.closeButtonContainer, key: CSS.closeButtonContainer }, h(\"calcite-action\", { appearance: \"transparent\", class: CSS.closeButton, onClick: this.hide, scale: this.scale, text: messages.close,\n      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)\n      ref: (closeButtonEl) => (this.closeButtonEl = closeButtonEl) }, h(\"calcite-icon\", { icon: \"x\", scale: getIconScale(this.scale) })))) : null;\n  }\n  renderHeader() {\n    const { heading, headingLevel } = this;\n    const headingNode = heading ? (h(Heading, { class: CSS.heading, level: headingLevel }, heading)) : null;\n    return headingNode ? (h(\"div\", { class: CSS.header, key: CSS.header }, headingNode, this.renderCloseButton())) : null;\n  }\n  render() {\n    const { effectiveReferenceElement, heading, label, open, pointerDisabled, floatingLayout } = this;\n    const displayed = effectiveReferenceElement && open;\n    const hidden = !displayed;\n    const arrowNode = !pointerDisabled ? (h(FloatingArrow, { floatingLayout: floatingLayout, key: \"floating-arrow\",\n      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)\n      ref: this.storeArrowEl })) : null;\n    return (h(Host, { \"aria-hidden\": toAriaBoolean(hidden), \"aria-label\": label, \"aria-live\": \"polite\", \"calcite-hydrated-hidden\": hidden, id: this.getId(), role: \"dialog\" }, h(\"div\", { class: {\n        [FloatingCSS.animation]: true,\n        [FloatingCSS.animationActive]: displayed,\n      },\n      // eslint-disable-next-line react/jsx-sort-props -- ref should be last so node attrs/props are in sync (see https://github.com/Esri/calcite-design-system/pull/6530)\n      ref: this.setTransitionEl }, arrowNode, h(\"div\", { class: {\n        [CSS.hasHeader]: !!heading,\n        [CSS.container]: true,\n      } }, this.renderHeader(), h(\"div\", { class: CSS.content }, h(\"slot\", null)), !heading ? this.renderCloseButton() : null))));\n  }\n  static get assetsDirs() { return [\"assets\"]; }\n  get el() { return this; }\n  static get watchers() { return {\n    \"focusTrapDisabled\": [\"handleFocusTrapDisabled\"],\n    \"flipPlacements\": [\"flipPlacementsHandler\"],\n    \"messageOverrides\": [\"onMessagesChange\"],\n    \"offsetDistance\": [\"offsetDistanceOffsetHandler\"],\n    \"offsetSkidding\": [\"offsetSkiddingHandler\"],\n    \"open\": [\"openHandler\"],\n    \"overlayPositioning\": [\"overlayPositioningHandler\"],\n    \"placement\": [\"placementHandler\"],\n    \"referenceElement\": [\"referenceElementHandler\"],\n    \"effectiveLocale\": [\"effectiveLocaleChange\"]\n  }; }\n  static get style() { return popoverCss; }\n}, [1, \"calcite-popover\", {\n    \"autoClose\": [516, \"auto-close\"],\n    \"closable\": [516],\n    \"flipDisabled\": [516, \"flip-disabled\"],\n    \"focusTrapDisabled\": [516, \"focus-trap-disabled\"],\n    \"pointerDisabled\": [516, \"pointer-disabled\"],\n    \"flipPlacements\": [16],\n    \"heading\": [1],\n    \"headingLevel\": [514, \"heading-level\"],\n    \"label\": [1],\n    \"messageOverrides\": [1040],\n    \"messages\": [1040],\n    \"offsetDistance\": [514, \"offset-distance\"],\n    \"offsetSkidding\": [514, \"offset-skidding\"],\n    \"open\": [1540],\n    \"overlayPositioning\": [513, \"overlay-positioning\"],\n    \"placement\": [513],\n    \"referenceElement\": [1, \"reference-element\"],\n    \"scale\": [513],\n    \"triggerDisabled\": [516, \"trigger-disabled\"],\n    \"effectiveLocale\": [32],\n    \"floatingLayout\": [32],\n    \"effectiveReferenceElement\": [32],\n    \"defaultMessages\": [32],\n    \"reposition\": [64],\n    \"setFocus\": [64],\n    \"updateFocusTrapElements\": [64]\n  }]);\nfunction defineCustomElement() {\n  if (typeof customElements === \"undefined\") {\n    return;\n  }\n  const components = [\"calcite-popover\", \"calcite-action\", \"calcite-icon\", \"calcite-loader\"];\n  components.forEach(tagName => { switch (tagName) {\n    case \"calcite-popover\":\n      if (!customElements.get(tagName)) {\n        customElements.define(tagName, Popover);\n      }\n      break;\n    case \"calcite-action\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$3();\n      }\n      break;\n    case \"calcite-icon\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$2();\n      }\n      break;\n    case \"calcite-loader\":\n      if (!customElements.get(tagName)) {\n        defineCustomElement$1();\n      }\n      break;\n  } });\n}\ndefineCustomElement();\n\nexport { Popover as P, defineCustomElement as d };\n"],"names":["Heading","props","children","HeadingTag","level","concat","h","getRoundRobinIndex","index","total","CSS","SLOTS","tooltip","trigger","ICONS","SUPPORTED_MENU_NAV_KEYS","ActionMenu","proxyCustomElement","HTMLElement","constructor","_this","super","this","__registerHost","__attachShadow","calciteActionMenuOpen","createEvent","actionElements","guid","menuId","menuButtonId","connectMenuButtonEl","open","label","menuButtonEl","slottedMenuButtonEl","defaultMenuButtonEl","disconnectMenuButtonEl","setTooltipReferenceElement","active","setAttribute","toAriaBoolean","id","text","addEventListener","menuButtonClick","menuButtonKeyDown","removeEventListener","setMenuButtonEl","event","actions","target","assignedElements","flatten","filter","el","matches","setDefaultMenuButtonEl","handleCalciteActionClick","setFocus","isPrimaryPointerButton","toggleOpen","updateTooltip","tooltips","tooltipEl","expanded","referenceElement","updateAction","action","activeMenuItemIndex","tabIndex","toggleAttribute","updateActions","forEach","handleDefaultSlotChange","key","length","isActivationKey","preventDefault","click","handleActionNavigation","isValidKey","currentIndex","Math","max","toggleOpenEnd","value","arguments","undefined","appearance","flipPlacements","overlayPositioning","placement","scale","componentWillLoad","setUpLoadableComponent","componentDidLoad","setComponentLoaded","disconnectedCallback","expandedHandler","openHandler","emit","closeCalciteActionMenuOnClick","composedPath","includes","activeMenuItemIndexHandler","componentFocusable","focusElement","renderMenuButton","name","onSlotchange","class","icon","textEnabled","ref","renderMenuItems","activeAction","activeDescendantId","focusTrapDisabled","offsetDistance","pointerDisabled","onClick","role","render","Fragment","supportedKeys","find","k","watchers","style","defineCustomElement","customElements","tagName","get","define","defineCustomElement$4","defineCustomElement$3","defineCustomElement$2","defineCustomElement$1","freeGlobal","global","Object","freeSelf","self","root","Function","Symbol","objectProto$1","prototype","hasOwnProperty","nativeObjectToString$1","toString","symToStringTag$1","toStringTag","nativeObjectToString","nullTag","undefinedTag","symToStringTag","baseGetTag","isOwn","call","tag","unmasked","e","result","getRawTag","objectToString","isObjectLike","symbolTag","isSymbol","reWhitespace","reTrimStart","baseTrim","string","slice","test","charAt","trimmedEndIndex","replace","isObject","type","NAN","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","toNumber","other","valueOf","isBinary","now","Date","FUNC_ERROR_TEXT","nativeMax","nativeMin","min","debounce","func","wait","options","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","apply","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","setTimeout","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","clearTimeout","cancel","flush","isOpen","component","opened","emitImmediately","nonOpenCloseComponent","transitionProp","onBeforeOpen","onBeforeClose","onOpen","onClose","onToggleOpenCloseComponent","readTask","transitionEl","_allTransitionDuratio","transitionDuration","allDurations","transitionProperty","allProps","getComputedStyle","allTransitionDurationsArray","split","indexOf","openTransitionProp","fallbackTimeoutId","onStart","onEndOrCancel","parseFloat","propertyName","sides","alignments","placements","reduce","acc","side","round","floor","createCoords","v","x","y","oppositeSideMap","left","right","bottom","top","oppositeAlignmentMap","start","end","clamp","evaluate","param","getSide","getAlignment","getOppositeAxis","axis","getAxisLength","getSideAxis","getAlignmentAxis","getAlignmentSides","rects","rtl","alignment","alignmentAxis","mainAlignmentSide","reference","floating","getOppositePlacement","getOppositeAlignmentPlacement","getPaddingObject","padding","expandPaddingObject","rectToClientRect","rect","width","height","computeCoordsFromPlacement","_ref","sideAxis","alignLength","isVertical","commonX","commonY","commonAlign","coords","async","detectOverflow","state","_await$platform$isEle","platform","elements","strategy","boundary","rootBoundary","elementContext","altBoundary","paddingObject","element","clippingClientRect","getClippingRect","isElement","contextElement","getDocumentElement","offsetParent","getOffsetParent","offsetScale","getScale","elementClientRect","convertOffsetParentRelativeRectToViewportRelativeRect","autoPlacement","fn","_middlewareData$autoP","_middlewareData$autoP2","_placementsThatFitOnE","middlewareData","crossAxis","allowedPlacements","autoAlignment","detectOverflowOptions","placements$1","getPlacementList","overflow","currentPlacement","alignmentSides","isRTL","reset","currentOverflows","allOverflows","overflows","nextPlacement","data","placementsSortedByMostSpace","map","d","sort","a","b","resetPlacement","every","flip","_middlewareData$arrow","_middlewareData$flip","initialPlacement","mainAxis","checkMainAxis","checkCrossAxis","fallbackPlacements","specifiedFallbackPlacements","fallbackStrategy","fallbackAxisSideDirection","flipAlignment","arrow","alignmentOffset","isBasePlacement","oppositePlacement","getExpandedPlacements","push","direction","list","isStart","lr","rl","tb","bt","getSideList","getOppositeAxisPlacements","overflowsData","_middlewareData$flip2","_overflowsData$filter","nextIndex","_overflowsData$map$so","getSideOffsets","isAnySideFullyClipped","some","hide","offsets","referenceHiddenOffsets","referenceHidden","escapedOffsets","escaped","offset","diffCoords","mainAxisMulti","crossAxisMulti","rawValue","convertValueToCoords","getNodeName","node","isNode","nodeName","toLowerCase","getWindow","_node$ownerDocument","ownerDocument","defaultView","window","document","documentElement","Node","Element","isHTMLElement","isShadowRoot","ShadowRoot","isOverflowElement","overflowX","overflowY","display","getComputedStyle$1","isTableElement","isContainingBlock","webkit","isWebKit","css","transform","perspective","containerType","backdropFilter","willChange","contain","supports","isLastTraversableNode","getNodeScroll","scrollLeft","scrollTop","pageXOffset","pageYOffset","getParentNode","assignedSlot","parentNode","host","getNearestOverflowAncestor","body","getOverflowAncestors","traverseIframes","_node$ownerDocument2","scrollableAncestor","isBody","win","visualViewport","frameElement","getCssDimensions","hasOffset","offsetWidth","offsetHeight","shouldFallback","$","unwrapElement","domElement","getBoundingClientRect","Number","isFinite","noOffsets","getVisualOffsets","offsetLeft","offsetTop","includeScale","isFixedStrategy","clientRect","visualOffsets","isFixed","floatingOffsetParent","shouldAddVisualOffsets","offsetWin","currentIFrame","iframeScale","iframeRect","clientLeft","paddingLeft","clientTop","paddingTop","getWindowScrollBarX","getClientRectFromClippingAncestor","clippingAncestor","html","clientWidth","clientHeight","visualViewportBased","getViewportRect","scroll","scrollWidth","scrollHeight","getDocumentRect","getInnerBoundingClientRect","hasFixedPositionAncestor","stopNode","position","getRectRelativeToOffsetParent","isOffsetParentAnElement","offsetRect","getTrueOffsetParent","polyfill","currentNode","getContainingBlock","clippingAncestors","cache","cachedResult","currentContainingBlockComputedStyle","elementIsFixed","computedStyle","currentNodeIsContaining","ancestor","set","getClippingElementAncestors","_c","firstClippingAncestor","clippingRect","accRect","getElementRects","getOffsetParentFn","getDimensionsFn","getDimensions","getClientRects","Array","from","autoUpdate","update","ancestorScroll","ancestorResize","elementResize","ResizeObserver","layoutShift","IntersectionObserver","animationFrame","referenceEl","ancestors","passive","cleanupIo","onMove","timeoutId","io","cleanup","disconnect","refresh","skip","threshold","rootMargin","isFirstUpdate","handleObserve","entries","ratio","intersectionRatio","observe","observeMove","frameId","reobserveFrame","resizeObserver","firstEntry","unobserve","cancelAnimationFrame","requestAnimationFrame","prevRefRect","frameLoop","nextRefRect","computePosition","Map","mergedOptions","platformWithCache","config","middleware","validMiddleware","Boolean","statefulPlacement","resetCount","i","nextX","nextY","computePosition$1","flatTreeParent","offsetParentPolyfill","Build","isBrowser","originalGetOffsetParent","positionFloatingUI","_ref2","_middlewareData$hide","floatingEl","flipDisabled","offsetSkidding","arrowEl","effectivePlacement","getEffectivePlacement","getMiddleware","ARROW_CSS_TRANSFORM","floatingLayout","assign","visibility","pointerEvents","placementDataAttribute","repositionDebounceTimeout","effectivePlacements","FloatingCSS","_ref3","defaultMiddleware","limiter","mainAxisCoord","crossAxisCoord","maxSide","limitedCoords","arrowDimensions","isYAxis","minProp","maxProp","clientProp","endDiff","startDiff","arrowOffsetParent","clientSize","centerToReference","largestPossiblePadding","minPadding","maxPadding","min$1","center","shouldAddOffset","centerOffset","getElementDir","reverse","reposition","positionFunction","componentToDebouncedRepositionMap","getDebouncedReposition","cleanupMap","WeakMap","disconnectFloatingUI","_cleanupMap$get","_componentToDebounced","delete","defaultOffsetDistance","ceil","hypot","ownKeys","r","t","keys","getOwnPropertySymbols","o","getOwnPropertyDescriptor","enumerable","_objectSpread2","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","arg","input","hint","prim","toPrimitive","res","String","_toPrimitive","_toPropertyKey","configurable","writable","activeFocusTraps","trapStack","trap","activeTrap","pause","trapIndex","splice","unpause","isTabEvent","keyCode","isKeyForward","shiftKey","isKeyBackward","delay","findIndex","arr","idx","valueOrHandler","_len","params","_key","getActualTarget","shadowRoot","internalTrapStack","createFocusTrap","userOptions","doc","returnFocusOnDeactivate","escapeDeactivates","delayInitialFocus","containers","containerGroups","tabbableGroups","nodeFocusedBeforeActivation","mostRecentlyFocusedNode","paused","delayInitialFocusTimer","recentNavEvent","getOption","configOverrideOptions","optionName","configOptionName","findContainerIndex","container","tabbableNodes","contains","getNodeForOption","optionValue","_len2","_key2","Error","querySelector","getInitialFocusNode","isFocusable","tabbableOptions","activeElement","firstTabbableGroup","firstTabbableNode","updateTabbableNodes","tabbable","focusableNodes","focusable","lastTabbableNode","firstDomTabbableNode","isTabbable","lastDomTabbableNode","posTabIndexesFound","getTabIndex","nextTabbableNode","forward","nodeIdx","group","g","getActiveElement","tryFocus","focus","preventScroll","select","isSelectableInput","getReturnFocusNode","previousActiveElement","findNextNavNode","_ref2$isBackward","isBackward","destinationNode","containerIndex","containerGroup","startOfGroupIndex","destinationGroupIndex","destinationGroup","lastOfGroupIndex","_ref4","_destinationGroupIndex","_destinationGroup","checkPointerDown","clickOutsideDeactivates","deactivate","returnFocus","allowOutsideClick","checkFocusIn","targetContained","Document","nextNode","stopImmediatePropagation","navAcrossContainers","mruContainerIdx","mruTabIdx","n","checkKey","checkKeyNav","checkClick","addListeners","capture","removeListeners","mutationObserver","MutationObserver","mutations","mutation","removedNodes","updateObservedNodes","subtree","childList","activate","activateOptions","onActivate","onPostActivate","checkCanFocusTrap","finishActivation","then","deactivateOptions","onDeactivate","onPostDeactivate","checkCanReturnFocus","finishDeactivation","pauseOptions","onPause","onPostPause","unpauseOptions","onUnpause","onPostUnpause","updateContainerElements","containerElements","elementsAsArray","customConfig","globalThis","focusTrapStack","activateFocusTrap","_component$focusTrap","focusTrap","deactivateFocusTrap","_component$focusTrap2","DEFAULTS","strokeWidth","FloatingArrow","svgX","dValue","viewBox","fill","stroke","ARIA_CONTROLS","ARIA_EXPANDED","manager","registeredElements","registeredElementCount","queryPopover","registeredElement","pathEl","has","togglePopovers","togglePopover","triggerDisabled","values","popover","autoClose","keyHandler","defaultPrevented","closeAllPopovers","clickHandler","registerElement","unregisterElement","Popover","calcitePopoverBeforeClose","calcitePopoverClose","calcitePopoverBeforeOpen","calcitePopoverOpen","createObserver","updateFocusTrapElements","hasLoaded","setTransitionEl","setFilteredPlacements","filteredFlipPlacements","filteredPlacements","console","warn","join","trim","filterComputedPlacements","setUpReferenceElement","removeReferences","effectiveReferenceElement","getReferenceElement","runAutoUpdate","_refEl","_floatingEl","updateCallback","connectFloatingUI","addReferences","getId","setExpandedAttr","removeAttribute","storeArrowEl","closable","heading","headingLevel","messageOverrides","messages","effectiveLocale","defaultMessages","handleFocusTrapDisabled","flipPlacementsHandler","onMessagesChange","offsetDistanceOffsetHandler","offsetSkiddingHandler","overlayPositioningHandler","placementHandler","referenceElementHandler","effectiveLocaleChange","updateMessages","connectedCallback","connectLocalized","connectMessages","focusTrapNode","focusTrapEl","focusTrapOptions","fallbackFocus","setReturnFocus","connectFocusTrap","setUpMessages","disconnectLocalized","disconnectMessages","delayed","forceUpdate","focusFirstTabbable","_component$focusTrap3","queryElementRoots","renderCloseButton","close","closeButtonEl","getIconScale","renderHeader","headingNode","displayed","hidden","arrowNode","Host","assetsDirs"],"sourceRoot":""}